Execute (Initialize test environment):
  Save &rtp, g:plug_home, $MYVIMRC

  let vader = fnamemodify(globpath(&rtp, 'autoload/vader.vim'), ':h:h')
  let plug  = fnamemodify(globpath(&rtp, 'autoload/plug.vim'), ':h:h')
  set rtp=$HOME/.vim,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,$HOME/.vim/after
  execute 'set rtp^='.vader
  execute 'set rtp^='.plug
  let basertp = &rtp

  unlet! g:plugs
  unlet! g:plug_home

  set t_Co=256
  colo default
  pclose

  let g:vimrc_reloaded = 0
  let vimrc    = tempname()
  call writefile(['let g:vimrc_reloaded += 1'], vimrc)
  let $MYVIMRC = vimrc

Execute (plug#end() before plug#begin() should fail):
  try
    call plug#end()
    Assert 0, 'should not reach here'
  catch
    Assert stridx(v:exception, 'Call plug#begin() first') >= 0
  endtry

Execute (plug#begin() without path argument):
  call plug#begin()
  AssertEqual split(&rtp, ',')[0].'/plugged', g:plug_home
  unlet g:plug_home

Execute (plug#begin() without path argument with empty &rtp):
  let save_rtp = &rtp
  set rtp=
  try
    call plug#begin()
    Assert 0, 'should not reach here'
  catch
    Assert stridx(v:exception, 'Unable to determine plug home') >= 0, 'Got: '.v:exception
  endtry
  let &rtp = save_rtp

Execute (plug#begin(path)):
  let temp_plugged = tempname()
  call plug#begin(temp_plugged.'/')
  Assert g:plug_home !~ '[/\\]$', 'Trailing / should be stripped from g:plug_home'

  AssertEqual 0, len(g:plugs)
  AssertEqual temp_plugged, g:plug_home
  AssertEqual basertp, &rtp

Execute (Subsequent plug#begin() calls will reuse g:plug_home):
  call plug#begin()
  AssertEqual temp_plugged, g:plug_home

Execute (Test Plug command):
  " Git repo with branch
  Plug 'junegunn/seoul256.vim', 'no-t_co'
  AssertEqual 'https://git:@github.com/junegunn/seoul256.vim.git', g:plugs['seoul256.vim'].uri
  AssertEqual join([temp_plugged, 'seoul256.vim/'], '/'), g:plugs['seoul256.vim'].dir
  AssertEqual 'no-t_co', g:plugs['seoul256.vim'].branch

  " Git URI
  Plug 'git@github.com:junegunn/vim-emoji.git'
  AssertEqual 'git@github.com:junegunn/vim-emoji.git', g:plugs['vim-emoji'].uri
  AssertEqual 'master', g:plugs['vim-emoji'].branch
  AssertEqual join([temp_plugged, 'vim-emoji/'], '/'), g:plugs['vim-emoji'].dir

  " vim-scripts/
  Plug 'beauty256'
  AssertEqual 'https://git:@github.com/vim-scripts/beauty256.git', g:plugs.beauty256.uri
  AssertEqual 'master', g:plugs.beauty256.branch

  AssertEqual 3, len(g:plugs)

Execute (Plug command with dictionary option):
  Plug 'junegunn/seoul256.vim', { 'branch': 'no-t_co', 'rtp': '././' }
  AssertEqual join([temp_plugged, 'seoul256.vim/'], '/'), g:plugs['seoul256.vim'].dir
  AssertEqual '././', g:plugs['seoul256.vim'].rtp

  AssertEqual 3, len(g:plugs)

Execute (PlugStatus before installation):
  PlugStatus
  AssertEqual 3, len(filter(getline(1, line('$')), 'v:val =~ "Not found"'))
  q

Execute (PlugClean before installation):
  PlugClean
  AssertEqual 1, len(filter(getline(1, line('$')), 'v:val =~ "Already clean"'))
  q

Execute (plug#end() updates &rtp):
  call plug#end()
  Assert len(&rtp) > len(basertp)

Execute (Yet, plugins are not available):
  Assert empty(globpath(&rtp, 'autoload/emoji.vim'))

Execute (PlugInstall):
  PlugInstall
  AssertEqual 1, g:vimrc_reloaded
  q

Execute (Plugin available after installation):
  Assert !empty(globpath(&rtp, 'autoload/emoji.vim'))

Execute (PlugClean after installation):
  PlugClean
  AssertEqual 1, len(filter(getline(1, line('$')), 'v:val =~ "Already clean"'))
  q

Execute (PlugStatus after installation):
  PlugStatus
  AssertEqual 3, len(filter(getline(1, line('$')), 'v:val =~ "OK"'))
  q

Execute (Change branch of seoul256.vim):
  call plug#begin()
  Plug 'junegunn/seoul256.vim'
  Plug 'git@github.com:junegunn/vim-emoji.git'
  call plug#end()

Execute (PlugStatus):
  PlugStatus
  %y
  q
  normal! P
  %sort
  g/^$/d

Expect:
      Invalid branch: no-t_co. Try PlugUpdate.
  - vim-emoji: OK
  Finished. 1 error(s).
  [==]
  x seoul256.vim:

Execute (Change URI of seoul256.vim):
  call plug#begin()
  Plug 'junegunn.choi/seoul256.vim'
  Plug 'git@github.com:junegunn/vim-emoji.git'
  call plug#end()

Execute (PlugStatus):
  PlugStatus
  %y
  q
  normal! P
  %sort
  g/^$/d

Expect:
      Expected:    https://git:@github.com/junegunn.choi/seoul256.vim.git
      Invalid URI: https://git:@github.com/junegunn/seoul256.vim.git
      PlugClean required.
  - vim-emoji: OK
  Finished. 1 error(s).
  [==]
  x seoul256.vim:

# TODO: does not work due to inputsave()
# Do (PlugClean):
#   :PlugClean\<Enter>y\<Enter>
#   ggyG
#   q
#   PGdd

Execute (PlugClean! to remove seoul256.vim):
  PlugClean!
  AssertEqual 1, len(filter(getline(1, line('$')), 'v:val =~ "Removed"'))
  Assert empty(globpath(&rtp, 'colors/seoul256.vim'))
  Assert !empty(globpath(&rtp, 'autoload/emoji.vim'))
  q

Execute (Change GIT URI of vim-emoji):
  call plug#begin()
  Plug 'junegunn/seoul256.vim'
  Plug 'junegunn/vim-emoji'
  call plug#end()

Execute (PlugStatus):
  PlugStatus
  %y
  q
  normal! P
  %sort
  g/^$/d

Expect:
      Expected:    https://git:@github.com/junegunn/vim-emoji.git
      Invalid URI: git@github.com:junegunn/vim-emoji.git
      Not found. Try PlugInstall.
      PlugClean required.
  Finished. 2 error(s).
  [==]
  x seoul256.vim:
  x vim-emoji:

Execute (PlugClean! to remove vim-emoji):
  PlugClean!
  AssertEqual 1, len(filter(getline(1, line('$')), 'v:val =~ "Removed"'))
  Assert empty(globpath(&rtp, 'colors/seoul256.vim'))
  Assert empty(globpath(&rtp, 'autoload/emoji.vim'))
  q

Execute (PlugUpdate to install both again):
  PlugUpdate
  AssertEqual 2, len(filter(getline(1, line('$')), 'v:val =~ "Cloning into"'))
  AssertEqual 2, g:vimrc_reloaded
  Assert !empty(globpath(&rtp, 'colors/seoul256.vim')), 'seoul256.vim should be found'
  Assert !empty(globpath(&rtp, 'autoload/emoji.vim')), 'vim-emoji should be found'
  q

Execute (PlugUpdate only to find out plugins are up-to-date, D key to check):
  PlugUpdate
  AssertEqual 2, len(filter(getline(1, line('$')), 'v:val =~ "Already up-to-date"'))
  AssertEqual 3, g:vimrc_reloaded
  normal D
  AssertEqual 'No updates.', getline(1)
  q

Execute (PlugDiff - 'No updates.'):
  PlugDiff
  AssertEqual 'No updates.', getline(1)
  q

Execute (Rollback recent updates, PlugUpdate, then PlugDiff):
  for repo in ['seoul256.vim', 'vim-emoji']
    call system(printf('cd %s/%s && git reset HEAD^^ --hard', g:plug_home, repo))
  endfor
  PlugUpdate

  " Now we have updates
  normal D
  AssertEqual 'Last update:', getline(1)

  " Preview commit
  silent! wincmd P
  AssertEqual 0, &previewwindow

  " ]] motion
  execute 'normal ]]'
  let lnum = line('.')
  AssertEqual 3, col('.')

  " Open commit preview
  execute "normal j\<cr>"
  wincmd P
  AssertEqual 1, &previewwindow
  AssertEqual 'git', &filetype

  " Back to plug window
  wincmd p

  " ]] motion
  execute 'normal $]]'
  AssertEqual lnum + 4, line('.')
  AssertEqual 3, col('.')

  " [[ motion
  execute 'normal 0[['
  AssertEqual lnum, line('.')
  AssertEqual 3, col('.')

  " q will close preview window as well
  normal q

  " We no longer have preview window
  silent! wincmd P
  AssertEqual 0, &previewwindow

  " q should not close preview window if it's already open
  pedit
  PlugDiff
  execute "normal ]]j\<cr>"
  normal q

  silent! wincmd P
  AssertEqual 1, &previewwindow
  pclose

Execute (Plug window in a new tab):
  PlugDiff
  tab new new-tab
  set buftype=nofile
  PlugUpdate
  normal D
  AssertEqual 'No updates.', getline(1)
  q
  AssertEqual 'new-tab', expand('%')
  q
  q

**********************************************************************
~ On-demand loading / Partial installation/update ~
**********************************************************************

Execute (Trying to execute on-demand commands when plugin is not installed):
  call plug#begin()
  Plug 'junegunn/vim-easy-align', { 'on': ['EasyAlign', 'LiveEasyAlign'] }
  call plug#end()

  Assert exists(':EasyAlign')
  Assert exists(':LiveEasyAlign')
  AssertThrows EasyAlign
  AssertThrows LiveEasyAlign
  Assert !exists(':EasyAlign')
  Assert !exists(':LiveEasyAlign')

Execute (New set of plugins):
  call plug#begin()
  Plug 'junegunn/vim-fnr' " Depends on vim-pseudocl
  Plug 'junegunn/vim-easy-align', { 'on': 'EasyAlign' }
  Plug 'junegunn/vim-redis',      { 'for': 'redis' }
  call plug#end()

Execute (Check commands):
  Assert !exists(':FNR'),          'FNR command should not be found'
  Assert !exists(':RedisExecute'), 'RedisExecute command should not be found'

Execute (Partial PlugInstall):
  PlugInstall vim-fnr vim-easy-align
  PlugInstall vim-fnr vim-easy-align 1
  q

Execute (Check dependent plugin):
  Assert &rtp =~ 'pseudocl', &rtp

Given (Unaligned code):
  a=1
  aa=2

Execute (Check installed plugins):
  Assert exists(':FNR'),           'FNR command should be found'
  Assert exists(':EasyAlign'),     'EasyAlign command should be found'
  Assert !exists(':RedisExecute'), 'RedisExecute command still should not be found'
  %EasyAlign=

Expect (Aligned code):
  a  = 1
  aa = 2

Given (nothing):
Execute (Partial PlugUpdate):
  PlugUpdate vim-redis
  q

Execute (On-demand loading based on filetypes):
  Assert !exists(':RedisExecute'), 'RedisExecute command still should not be found'
  set ft=redis
  Assert exists(':RedisExecute'), 'RedisExecute command is now found'

Execute (Cleanup):
  call system('rm -rf '.temp_plugged)

  unlet g:plugs
  unlet g:plug_home
  unlet g:vimrc_reloaded
  unlet temp_plugged vader plug basertp save_rtp repo lnum

  Restore
  source $MYVIMRC
